from collections import defaultdict
from typing import Dict, List, NamedTuple, Tuple

from galois import GF2

from pyzx.graph.base import upair
from pyzx.linalg import Z2

from ..diagram import Diagram, NodeType
from ..pauli import Pauli


class GraphOrdering(NamedTuple):
    graph_to_ordering: Dict[int, int]
    ordering_to_graph: Dict[int, int]

    z_boundaries: Dict[int, int]
    internal_spiders: List[int]
    pi_2_spiders: List[int]

    def ord(self, s: int) -> int:
        return self.graph_to_ordering[s]

    def graph(self, o: int) -> int:
        return self.ordering_to_graph[o]


def determine_ordering(d: Diagram) -> GraphOrdering:
    boundaries = d.boundary_nodes()
    z_boundaries = {d.neighbors(b)[0]: b for b in boundaries}
    internal_spiders = list(set(d.node_indices()).difference(boundaries).difference(z_boundaries.keys()))
    pi_2_spiders = list(filter(lambda _v: d.phase(_v).denominator == 2, internal_spiders))

    graph_to_ordering: Dict[int, int] = dict()
    ordering_to_graph: Dict[int, int] = dict()
    idx = 0
    for boundary in z_boundaries.keys():
        graph_to_ordering[boundary] = idx
        ordering_to_graph[idx] = boundary
        idx += 1
    for internal in set(internal_spiders).difference(pi_2_spiders):
        graph_to_ordering[internal] = idx
        ordering_to_graph[idx] = internal
        idx += 1
    for pi_2_spider in pi_2_spiders:
        graph_to_ordering[pi_2_spider] = idx
        ordering_to_graph[idx] = pi_2_spider
        idx += 1

    return GraphOrdering(graph_to_ordering, ordering_to_graph, z_boundaries, internal_spiders, pi_2_spiders)


def create_firing_verification(d: Diagram, ordering: GraphOrdering) -> GF2:
    num_z_boundaries = len(ordering.z_boundaries)
    num_non_boundary_spiders = num_z_boundaries + len(ordering.internal_spiders)
    adj_matrix = GF2.Zeros((num_non_boundary_spiders, num_non_boundary_spiders))

    for s, t in d.edge_list():
        if d.type(s) != NodeType.B and d.type(t) != NodeType.B:
            adj_matrix[ordering.ord(s), ordering.ord(t)] = 1
            adj_matrix[ordering.ord(t), ordering.ord(s)] = 1

    rows, cols = num_non_boundary_spiders, num_non_boundary_spiders + num_z_boundaries
    m_d = GF2.Zeros((rows, cols))

    m_d[0:num_z_boundaries, 0:num_z_boundaries] = GF2.Identity(num_z_boundaries)

    m_d[:, num_z_boundaries:] = adj_matrix

    num_pi_2 = len(ordering.pi_2_spiders)
    slice_key = (slice(rows - num_pi_2, rows), slice(cols - num_pi_2, cols))
    m_d[slice_key] = m_d[slice_key].view(dtype=bool) ^ GF2.Identity(num_pi_2).view(dtype=bool)

    return m_d


def convert_firing_assignment_to_web_prototype(
    d: Diagram, ordering: GraphOrdering, v: List[Z2]
) -> Dict[Tuple[int, int], Pauli]:
    prot: Dict[Tuple[int, int], Pauli] = defaultdict(lambda: Pauli.I)

    for adj_vertex, g_vertex in ordering.ordering_to_graph.items():
        g_type = d.type(g_vertex)
        # Fire all green spiders with full red edges and thus their red neighbours
        if g_type == NodeType.Z and v[adj_vertex + len(ordering.z_boundaries)] == 1:
            for _n in d.neighbors(g_vertex):
                prot[upair(g_vertex, _n)] *= Pauli.X
        # Fire all red spiders with full green edges and thus their green neighbours
        if g_type == NodeType.X and v[adj_vertex + len(ordering.z_boundaries)] == 1:
            for _n in d.neighbors(g_vertex):
                prot[upair(g_vertex, _n)] *= Pauli.Z

    # Fire all green output edges
    for g_z_boundary, g_boundary in ordering.z_boundaries.items():
        adj_z_boundary = ordering.ord(g_z_boundary)
        if v[adj_z_boundary] == 1:
            prot[upair(g_z_boundary, g_boundary)] *= Pauli.Z

    return prot
